using CrimsonSports.Api.Data;
using CrimsonSports.Api.Models;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using System.Linq;

namespace CrimsonSports.Api.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class TransactionsController : ControllerBase
    {
        private readonly AppDbContext _context;

        public TransactionsController(AppDbContext context)
        {
            _context = context;
        }

        public class CartItemDto
        {
            public int ProductID { get; set; }
            public int Quantity { get; set; }
        }

        public class CreateTransactionRequest
        {
            public int CustomerID { get; set; }
            public int EmployeeID { get; set; } // for simplicity, pick 1 or from login
            public string PaymentMethod { get; set; } = "Credit";
            public List<CartItemDto> Items { get; set; } = new();
        }

        [HttpPost]
        public async Task<IActionResult> CreateTransaction([FromBody] CreateTransactionRequest request)
        {
            if (request.Items == null || request.Items.Count == 0)
            {
                return BadRequest("Cart is empty.");
            }

            using var transaction = await _context.Database.BeginTransactionAsync();

            var newTrans = new CustomerPurchaseTransaction
            {
                CustomerID = request.CustomerID,
                EmployeeID = request.EmployeeID,
                TransactionDate = DateTime.Now,
                PaymentMethod = request.PaymentMethod,
                Status = "Pending" // New orders start as Pending for manager confirmation
            };

            _context.CustomerPurchaseTransactions.Add(newTrans);
            await _context.SaveChangesAsync();

            decimal total = 0m;

            foreach (var item in request.Items)
            {
                var product = await _context.Products.FirstOrDefaultAsync(p => p.ProductID == item.ProductID);
                if (product == null) continue;

                if (product.StockQuantity < item.Quantity)
                {
                    await transaction.RollbackAsync();
                    return BadRequest($"Not enough stock for {product.ProductName}.");
                }

                var detail = new TransactionDetail
                {
                    TransactionID = newTrans.TransactionID,
                    ProductID = product.ProductID,
                    Quantity = item.Quantity,
                    UnitPrice = product.Price
                    // Subtotal is a generated column in MySQL, so don't set it - let the database calculate it
                };

                _context.TransactionDetails.Add(detail);

                product.StockQuantity -= item.Quantity;
                // Calculate subtotal manually for the total (since Subtotal is generated by DB)
                total += product.Price * item.Quantity;
            }

            newTrans.TotalAmount = total;
            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            return Ok(new { newTrans.TransactionID, newTrans.TotalAmount });
        }

        // GET: api/transactions - Get all transactions (for managers)
        [HttpGet]
        public async Task<IActionResult> GetTransactions()
        {
            var transactions = await _context.CustomerPurchaseTransactions
                .Include(t => t.Customer)
                .Include(t => t.Employee)
                .Include(t => t.TransactionDetails)
                    .ThenInclude(td => td.Product)
                .OrderByDescending(t => t.TransactionDate)
                .ToListAsync();

            // Map to DTOs to avoid circular references and reduce payload size
            var result = transactions.Select(t => new
            {
                transactionID = t.TransactionID,
                customerID = t.CustomerID,
                employeeID = t.EmployeeID,
                transactionDate = t.TransactionDate,
                paymentMethod = t.PaymentMethod,
                totalAmount = t.TotalAmount,
                status = t.Status,
                customer = t.Customer != null ? new
                {
                    customerID = t.Customer.CustomerID,
                    firstName = t.Customer.FirstName,
                    lastName = t.Customer.LastName,
                    email = t.Customer.Email
                } : null,
                employee = t.Employee != null ? new
                {
                    employeeID = t.Employee.EmployeeID,
                    firstName = t.Employee.FirstName,
                    lastName = t.Employee.LastName,
                    email = t.Employee.Email,
                    role = t.Employee.Role
                } : null,
                transactionDetails = (t.TransactionDetails ?? new List<TransactionDetail>()).Select(td => new
                {
                    transactionDetailID = td.TransactionDetailID,
                    productID = td.ProductID,
                    quantity = td.Quantity,
                    unitPrice = td.UnitPrice,
                    subtotal = td.Subtotal,
                    product = td.Product != null ? new
                    {
                        productID = td.Product.ProductID,
                        productName = td.Product.ProductName,
                        category = td.Product.Category,
                        price = td.Product.Price
                    } : null
                }).ToList()
            }).ToList();

            return Ok(result);
        }

        // GET: api/transactions/{id} - Get transaction details
        [HttpGet("{id}")]
        public async Task<IActionResult> GetTransaction(int id)
        {
            var transaction = await _context.CustomerPurchaseTransactions
                .Include(t => t.Customer)
                .Include(t => t.Employee)
                .Include(t => t.TransactionDetails)
                    .ThenInclude(td => td.Product)
                .FirstOrDefaultAsync(t => t.TransactionID == id);

            if (transaction == null) return NotFound();
            
            // Map to DTO to avoid circular references
            var result = new
            {
                transactionID = transaction.TransactionID,
                customerID = transaction.CustomerID,
                employeeID = transaction.EmployeeID,
                transactionDate = transaction.TransactionDate,
                paymentMethod = transaction.PaymentMethod,
                totalAmount = transaction.TotalAmount,
                status = transaction.Status,
                customer = transaction.Customer != null ? new
                {
                    customerID = transaction.Customer.CustomerID,
                    firstName = transaction.Customer.FirstName,
                    lastName = transaction.Customer.LastName,
                    email = transaction.Customer.Email
                } : null,
                employee = transaction.Employee != null ? new
                {
                    employeeID = transaction.Employee.EmployeeID,
                    firstName = transaction.Employee.FirstName,
                    lastName = transaction.Employee.LastName,
                    email = transaction.Employee.Email,
                    role = transaction.Employee.Role
                } : null,
                transactionDetails = (transaction.TransactionDetails ?? new List<TransactionDetail>()).Select(td => new
                {
                    transactionDetailID = td.TransactionDetailID,
                    productID = td.ProductID,
                    quantity = td.Quantity,
                    unitPrice = td.UnitPrice,
                    subtotal = td.Subtotal,
                    product = td.Product != null ? new
                    {
                        productID = td.Product.ProductID,
                        productName = td.Product.ProductName,
                        category = td.Product.Category,
                        price = td.Product.Price
                    } : null
                }).ToList()
            };
            
            return Ok(result);
        }

        // PUT: api/transactions/{id}/status - Update transaction status
        [HttpPut("{id}/status")]
        public async Task<IActionResult> UpdateStatus(int id, [FromBody] UpdateStatusRequest request)
        {
            try
            {
                if (request == null || string.IsNullOrWhiteSpace(request.Status))
                {
                    return BadRequest("Status is required.");
                }

                var transaction = await _context.CustomerPurchaseTransactions.FindAsync(id);
                if (transaction == null)
                {
                    return NotFound($"Transaction with ID {id} not found.");
                }

                // Validate status values (using shorter names to fit database column size)
                var validStatuses = new[] { "Pending", "Confirm", "Process", "Shipped", "Done", "Cancel" };
                if (!validStatuses.Contains(request.Status))
                {
                    return BadRequest($"Invalid status. Valid statuses are: {string.Join(", ", validStatuses)}");
                }

                transaction.Status = request.Status;
                await _context.SaveChangesAsync();

                // Return a simple response to avoid serialization issues
                return Ok(new
                {
                    transactionID = transaction.TransactionID,
                    status = transaction.Status,
                    message = "Status updated successfully"
                });
            }
            catch (Exception ex)
            {
                return StatusCode(500, new
                {
                    message = "An error occurred while updating the transaction status.",
                    error = ex.Message,
                    innerException = ex.InnerException?.Message
                });
            }
        }

        public class UpdateStatusRequest
        {
            public string Status { get; set; } = string.Empty;
        }
    }
}

